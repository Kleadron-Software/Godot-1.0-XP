import os

def add_source_files(self, sources, filetype, lib_env = None, shared = False):
	import glob;
	import string;
	#if not lib_objects:
	if not lib_env:
		lib_env = self
	if type(filetype) == type(""):

		dir = self.Dir('.').abspath
		list = glob.glob(dir + "/"+filetype)
		for f in list:
			sources.append( self.Object(f) )
	else:
		for f in filetype:
			sources.append(self.Object(f))
			

def build_shader_header( target, source, env ): 

	for x in source:
		print x
		
		name = str(x)
		name = name[ name.rfind("/")+1: ]
		name = name[ name.rfind("\\")+1: ]
		name = name.replace(".","_")
		
		
		fs = open(str(x),"r")
		fd = open(str(x)+".h","w")
		fd.write("/* this file has been generated by SCons, do not edit! */\n")
		fd.write("static const char *"+name+"=\n")
		line=fs.readline()
		while(line):
			line=line.replace("\r","")
			line=line.replace("\n","")
			line=line.replace("\\","\\\\")
			line=line.replace("\"","\\\"")
			fd.write("\""+line+"\\n\"\n")
			line=fs.readline()
			
		fd.write(";\n")
			
	return 0
		
		
def build_glsl_header( filename ): 
		
	fs = open(filename,"r")	
	line=fs.readline()
	
	vertex_lines=[]
	fragment_lines=[]
	uniforms=[]
	attributes=[]
	fbos=[]
	conditionals=[]
	texunits=[]
	texunit_names=[]
	ubos=[]
	ubo_names=[]

	reading=""
	line_offset=0
	vertex_offset=0
	fragment_offset=0

	while(line):
		
		if (line.find("[vertex]")!=-1):
			reading="vertex"
			line=fs.readline()
			line_offset+=1
			vertex_offset=line_offset
			continue
		
		if (line.find("[fragment]")!=-1):
			reading="fragment"
			line=fs.readline()
			line_offset+=1
			fragment_offset=line_offset
			continue
		
		if (line.find("#ifdef ")!=-1):
			ifdefline = line.replace("#ifdef ","").strip()
			if (not ifdefline in conditionals):
				conditionals+=[ifdefline]

		if (line.find("#elif defined(")!=-1):
			ifdefline = line.replace("#elif defined(","").strip()
			ifdefline = ifdefline.replace(")","").strip()
			if (not ifdefline in conditionals):
				conditionals+=[ifdefline]


		import re
		if re.search(r"^\s*uniform", line):

			if (line.lower().find("texunit:")!=-1):
				#texture unit
				texunit = str(int( line[line.find(":")+1:].strip() ))
				uline=line[:line.lower().find("//")]
				uline = uline.replace("uniform","");
				uline = uline.replace(";","");
				lines = uline.split(",")
				for x in lines:

					x = x.strip()
					x = x[ x.rfind(" ")+1: ]
					if (x.find("[")!=-1):
						#unfiorm array
						x = x[ :x.find("[") ]

					if (not x in texunit_names):
						texunits+=[(x,texunit)]
						texunit_names+=[x]

			elif (line.lower().find("ubo:")!=-1):
				#ubo
				uboidx = str(int( line[line.find(":")+1:].strip() ))
				uline=line[:line.lower().find("//")]
				uline = uline[uline.find("uniform")+len("uniform"):];
				uline = uline.replace(";","");
				uline = uline.replace("{","");
				lines = uline.split(",")
				for x in lines:

					x = x.strip()
					x = x[ x.rfind(" ")+1: ]
					if (x.find("[")!=-1):
						#unfiorm array
						x = x[ :x.find("[") ]

					if (not x in ubo_names):
						ubos+=[(x,uboidx)]
						ubo_names+=[x]



			else:
				uline = line.replace("uniform","");
				uline = uline.replace(";","");
				lines = uline.split(",")
				for x in lines:

					x = x.strip()
					x = x[ x.rfind(" ")+1: ]
					if (x.find("[")!=-1):
						#unfiorm array
						x = x[ :x.find("[") ]

					if (not x in uniforms):
						uniforms+=[x]

		if ((line.strip().find("in ")==0 or line.strip().find("attribute ")==0) and line.find("attrib:")!=-1):
			uline = line.replace("in ","");
			uline = uline.replace("attribute ","");
			uline = uline.replace(";","");
			uline = uline[ uline.find(" "): ].strip()
			
			
			if (uline.find("//")!=-1):
				name,bind = uline.split("//")
				if (bind.find("attrib:")!=-1):
					name=name.strip()
					bind=bind.replace("attrib:","").strip()
					attributes+=[(name,bind)]
			
		if (line.strip().find("out ")==0):
			uline = line.replace("out","").strip();
			uline = uline.replace(";","");
			uline = uline[ uline.find(" "): ].strip()
			
			
			if (uline.find("//")!=-1):
				name,bind = uline.split("//")
				if (bind.find("drawbuffer:")!=-1):
					name=name.strip()
					bind=bind.replace("drawbuffer:","").strip()
					fbos+=[(name,bind)]
			
		line=line.replace("\r","")
		line=line.replace("\n","")
		line=line.replace("\\","\\\\")
		line=line.replace("\"","\\\"")
		#line=line+"\\n\\" no need to anymore
		
		if (reading=="vertex"):
			vertex_lines+=[line]
		if (reading=="fragment"):
			fragment_lines+=[line]
			
		line=fs.readline()
		line_offset+=1

	fs.close();
	
	out_file = filename+".h"
	fd = open(out_file,"w")
	
	fd.write("/* WARNING, THIS FILE WAS GENERATED, DO NOT EDIT */\n");
	
	out_file_base = out_file
	out_file_base = out_file_base[ out_file_base.rfind("/")+1: ]
	out_file_base = out_file_base[ out_file_base.rfind("\\")+1: ]
#	print("out file "+out_file+" base " +out_file_base)
	out_file_ifdef = out_file_base.replace(".","_").upper()
	fd.write("#ifndef "+out_file_ifdef+"\n")
	fd.write("#define "+out_file_ifdef+"\n")
	
	out_file_class = out_file_base.replace(".glsl.h","").title().replace("_","").replace(".","")+"ShaderGL";
	fd.write("\n\n");
	fd.write("#include \"drivers/opengl/shader_gl.h\"\n\n\n");
	fd.write("class "+out_file_class+" : public ShaderGL {\n\n");
	fd.write("\t virtual String get_shader_name() const { return \""+out_file_class+"\"; }\n");
	fd.write("public:\n\n");
	
	if (len(conditionals)):
		fd.write("\tenum Conditionals {\n");
		for x in conditionals:
			fd.write("\t\t"+x+",\n");
		fd.write("\t};\n\n");
	if (len(uniforms)):
		fd.write("\tenum Uniforms {\n");
		for x in uniforms:
			fd.write("\t\t"+x.upper()+",\n");
		fd.write("\t};\n\n");
		
	fd.write("\t_FORCE_INLINE_ int get_uniform(Uniforms p_uniform) const { return _get_uniform(p_uniform); }\n\n");		
	if (len(conditionals)):

		fd.write("\t_FORCE_INLINE_ void set_conditional(Conditionals p_conditional,bool p_enable)  {  _set_conditional(p_conditional,p_enable); }\n\n");		
	fd.write("\t#define _FU if (get_uniform(p_uniform)<0) return; ERR_FAIL_COND( get_active()!=this );\n\n ");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_value) { _FU glUniform1f(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, double p_value) { _FU glUniform1f(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint8_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int8_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint16_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int16_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint32_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int32_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint64_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int64_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, unsigned long p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, long p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Color& p_color) { _FU GLfloat col[4]={p_color.r,p_color.g,p_color.b,p_color.a}; glUniform4fv(get_uniform(p_uniform),1,col); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector2& p_vec2) { _FU GLfloat vec2[2]={p_vec2.x,p_vec2.y}; glUniform2fv(get_uniform(p_uniform),1,vec2); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector3& p_vec3) { _FU GLfloat vec3[3]={p_vec3.x,p_vec3.y,p_vec3.z}; glUniform3fv(get_uniform(p_uniform),1,vec3); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b) { _FU glUniform2f(get_uniform(p_uniform),p_a,p_b); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c) { _FU glUniform3f(get_uniform(p_uniform),p_a,p_b,p_c); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c, float p_d) { _FU glUniform4f(get_uniform(p_uniform),p_a,p_b,p_c,p_d); }\n\n");
	
	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Transform& p_transform) {  _FU

		const Transform &tr = p_transform;
	
		GLfloat matrix[16]={ /* build a 16x16 matrix */
			tr.basis.elements[0][0],
			tr.basis.elements[1][0],
			tr.basis.elements[2][0],
			0,
			tr.basis.elements[0][1],
			tr.basis.elements[1][1],
			tr.basis.elements[2][1],
			0,
			tr.basis.elements[0][2],
			tr.basis.elements[1][2],
			tr.basis.elements[2][2],
			0,
			tr.origin.x,
			tr.origin.y,
			tr.origin.z,
			1 
		};
	
	
	glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);
	
	
	}
	
	""");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Matrix32& p_transform) {  _FU

		const Matrix32 &tr = p_transform;

		GLfloat matrix[16]={ /* build a 16x16 matrix */
			tr.elements[0][0],
			tr.elements[0][1],
			0,
			0,
			tr.elements[1][0],
			tr.elements[1][1],
			0,
			0,
			0,
			0,
			1,
			0,
			tr.elements[2][0],
			tr.elements[2][1],
			0,
			1
		};


	glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);


	}

	""");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const CameraMatrix& p_matrix) {  _FU
	
		GLfloat matrix[16];
	
		for (int i=0;i<4;i++) {
			for (int j=0;j<4;j++) {
		
				matrix[i*4+j]=p_matrix.matrix[i][j];
			}	
		}
	
		glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);
	}; """);
	
	fd.write("\n\n#undef _FU\n\n\n");
	
	
	fd.write("\tvirtual void init() {\n\n");
	if (len(conditionals)):
	
		fd.write("\t\tstatic const char* _conditional_strings[]={\n")
		if (len(conditionals)):
			for x in conditionals:
				fd.write("\t\t\t\"#define "+x+"\\n\",\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_conditional_strings=NULL;\n")
	
	if (len(uniforms)):
	
		fd.write("\t\tstatic const char* _uniform_strings[]={\n")
		if (len(uniforms)):
			for x in uniforms:
				fd.write("\t\t\t\""+x+"\",\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_uniform_strings=NULL;\n")
	
	if (len(attributes)):
	
		fd.write("\t\tstatic AttributePair _attribute_pairs[]={\n")
		for x in attributes:
			fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic AttributePair *_attribute_pairs=NULL;\n")
	

	
	if (len(fbos)):
		fd.write("\t\tstatic FBOPair _fbo_pairs[]={\n")
		for x in fbos:
			fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic FBOPair *_fbo_pairs=NULL;\n")

	if (len(ubos)):
		fd.write("\t\tstatic UBOPair _ubo_pairs[]={\n")
		for x in ubos:
			fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic UBOPair *_ubo_pairs=NULL;\n")

	if (len(texunits)):
		fd.write("\t\tstatic TexUnitPair _texunit_pairs[]={\n")
		for x in texunits:
			fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic TexUnitPair *_texunit_pairs=NULL;\n")

	fd.write("\t\tstatic const char* _vertex_code=\"\\\n")
	for x in vertex_lines:
		fd.write("\t\t\t"+x+"\n");
	fd.write("\t\t\";\n\n");

	fd.write("\t\tstatic const int _vertex_code_start="+str(vertex_offset)+";\n")


	fd.write("\t\tstatic const char* _fragment_code=\"\\\n")
	for x in fragment_lines:
		fd.write("\t\t\t"+x+"\n");
	fd.write("\t\t\";\n\n");

	fd.write("\t\tstatic const int _fragment_code_start="+str(fragment_offset)+";\n")

	fd.write("\t\tsetup(_conditional_strings,"+str(len(conditionals))+",_uniform_strings,"+str(len(uniforms))+",_attribute_pairs,"+str(len(attributes))+",_fbo_pairs,"+str(len(fbos))+",_ubo_pairs,"+str(len(ubos))+",_texunit_pairs,"+str(len(texunits))+",_vertex_code,_fragment_code,_vertex_code_start,_fragment_code_start);\n")
	fd.write("\t};\n\n")
	
	fd.write("};\n\n");
	fd.write("#endif\n\n");
	fd.close();
	

def build_glsl_headers( target, source, env ): 

	for x in source:
		
		build_glsl_header(str(x));

			
	return 0		



def build_hlsl_dx9_header( filename ):

	fs = open(filename,"r")
	line=fs.readline()

	vertex_lines=[]
	fragment_lines=[]
	uniforms=[]
	fragment_uniforms=[]
	attributes=[]
	fbos=[]
	conditionals=[]

	reading=""
	line_offset=0
	vertex_offset=0
	fragment_offset=0

	while(line):

		if (line.find("[vertex]")!=-1):
			reading="vertex"
			line=fs.readline()
			line_offset+=1
			vertex_offset=line_offset
			continue

		if (line.find("[fragment]")!=-1):
			reading="fragment"
			line=fs.readline()
			line_offset+=1
			fragment_offset=line_offset
			continue

		if (line.find("#ifdef ")!=-1):
			ifdefline = line.replace("#ifdef ","").strip()
			if (not ifdefline in conditionals):
				conditionals+=[ifdefline]

		if (line.find("#elif defined(")!=-1):
			ifdefline = line.replace("#elif defined(","").strip()
			ifdefline = ifdefline.replace(")","").strip()
			if (not ifdefline in conditionals):
				conditionals+=[ifdefline]
		if (line.find("uniform")!=-1):
			uline = line.replace("uniform","");
			uline = uline.replace(";","");
			lines = uline.split(",")
			for x in lines:

				x = x.strip()
				x = x[ x.rfind(" ")+1: ]
				if (x.find("[")!=-1):
					#unfiorm array
					x = x[ :x.find("[") ]

				if (not x in uniforms):
					uniforms+=[x]
					fragment_uniforms+=[reading=="fragment"]
		line=line.replace("\r","")
		line=line.replace("\n","")
		line=line.replace("\\","\\\\")
		line=line.replace("\"","\\\"")
		line=line+"\\n\\"

		if (reading=="vertex"):
			vertex_lines+=[line]
		if (reading=="fragment"):
			fragment_lines+=[line]

		line=fs.readline()
		line_offset+=1

	fs.close();

	out_file = filename+".h"
	fd = open(out_file,"w")

	fd.write("/* WARNING, THIS FILE WAS GENERATED, DO NOT EDIT */\n");

	out_file_base = out_file
	out_file_base = out_file_base[ out_file_base.rfind("/")+1: ]
	out_file_base = out_file_base[ out_file_base.rfind("\\")+1: ]
#	print("out file "+out_file+" base " +out_file_base)
	out_file_ifdef = out_file_base.replace(".","_").upper()
	fd.write("#ifndef "+out_file_ifdef+"\n")
	fd.write("#define "+out_file_ifdef+"\n")

	out_file_class = out_file_base.replace(".hlsl.h","").title().replace("_","").replace(".","")+"ShaderDX9";
	fd.write("\n\n");
	fd.write("#include \"drivers/directx9/shader_dx9.h\"\n\n\n");
	fd.write("class "+out_file_class+" : public ShaderDX9 {\n\n");
	fd.write("\t virtual String get_shader_name() const { return \""+out_file_class+"\"; }\n");
	fd.write("public:\n\n");

	if (len(conditionals)):
		fd.write("\tenum Conditionals {\n");
		for x in conditionals:
			fd.write("\t\t"+x+",\n");
		fd.write("\t};\n\n");
	if (len(uniforms)):
		fd.write("\tenum Uniforms {\n");
		for x in uniforms:
			fd.write("\t\t"+x.upper()+",\n");
		fd.write("\t};\n\n");


	if (len(conditionals)):
		fd.write("\t_FORCE_INLINE_ void set_conditional(Conditionals p_conditional,bool p_enable)  {  _set_conditional(p_conditional,p_enable); }\n\n");

	fd.write("\t#define _FU if (!_uniform_valid(p_uniform)) return; ERR_FAIL_COND( get_active()!=this );\n\n ");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, bool p_value) { _FU set_uniformb(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_value) { _FU set_uniformf(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, double p_value) { _FU set_uniformf(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint8_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int8_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint16_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int16_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint32_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int32_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint64_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int64_t p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, unsigned long p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, long p_value) { _FU set_uniformi(p_uniform,p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Color& p_color) { _FU float col[4]={p_color.r,p_color.g,p_color.b,p_color.a}; set_uniformfv(p_uniform,col); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector2& p_vec2) { _FU float vec2[4]={p_vec2.x,p_vec2.y,0,0}; set_uniformfv(p_uniform,vec2); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector3& p_vec3) { _FU float vec3[4]={p_vec3.x,p_vec3.y,p_vec3.z,0}; set_uniformfv(p_uniform,vec3); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b) { _FU float vec2[4]={p_a,p_b,0,0}; set_uniformfv(p_uniform,vec2); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c) { _FU float vec3[4]={p_a,p_b,p_c,0}; set_uniformfv(p_uniform,vec3); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c, float p_d) { _FU float vec4[4]={p_a,p_b,p_c,p_d}; set_uniformfv(p_uniform,vec4); }\n\n");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Transform& p_transform) {  _FU

		const Transform &tr = p_transform;

		float matrix[16]={ /* build a 16x16 matrix */
			tr.basis.elements[0][0],
			tr.basis.elements[0][1],
			tr.basis.elements[0][2],
			tr.origin.x,
			tr.basis.elements[1][0],
			tr.basis.elements[1][1],
			tr.basis.elements[1][2],
			tr.origin.y,
			tr.basis.elements[2][0],
			tr.basis.elements[2][1],
			tr.basis.elements[2][2],
			tr.origin.z,
			0,
			0,
			0,
			1
		};

		set_uniformfv(p_uniform,&matrix[0],4);

	}

	""");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const CameraMatrix& p_matrix) {  _FU

		float matrix[16];

		for (int i=0;i<4;i++) {
			for (int j=0;j<4;j++) {

				matrix[i*4+j]=p_matrix.matrix[j][i];
			}
		}

		set_uniformfv(p_uniform,&matrix[0],4);
	}; """);

	fd.write("\n\n#undef _FU\n\n\n");


	fd.write("\tvirtual void init(IDirect3DDevice9 *p_device,ShaderSupport p_version) {\n\n");
	if (len(conditionals)):

		fd.write("\t\tstatic const char* _conditional_strings[]={\n")
		if (len(conditionals)):
			for x in conditionals:
				fd.write("\t\t\t\""+x+"\",\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_conditional_strings=NULL;\n")

	if (len(uniforms)):

		fd.write("\t\tstatic const char* _uniform_strings[]={\n")
		if (len(uniforms)):
			for x in uniforms:
				fd.write("\t\t\t\""+x+"\",\n");
		fd.write("\t\t};\n\n");

		fd.write("\t\tstatic const bool _fragment_uniforms[]={\n")

		if (len(uniforms)):
			for x in fragment_uniforms:
				if (x):
					fd.write("\t\t\ttrue,\n");
				else:
					fd.write("\t\t\tfalse,\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_uniform_strings=NULL;\n")
		fd.write("\t\tstatic const bool *_fragment_uniforms=NULL;\n")


	fd.write("\t\tstatic const char* _vertex_code=\"\\\n")
	for x in vertex_lines:
		fd.write("\t\t\t"+x+"\n");
	fd.write("\t\t\";\n\n");

	fd.write("\t\tstatic const int _vertex_code_start="+str(vertex_offset)+";\n")


	fd.write("\t\tstatic const char* _fragment_code=\"\\\n")
	for x in fragment_lines:
		fd.write("\t\t\t"+x+"\n");
	fd.write("\t\t\";\n\n");

	fd.write("\t\tstatic const int _fragment_code_start="+str(fragment_offset)+";\n")

	fd.write("\t\tsetup(p_device,p_version,_conditional_strings,"+str(len(conditionals))+",_uniform_strings,"+str(len(uniforms))+",_fragment_uniforms,_vertex_code,_fragment_code,_vertex_code_start,_fragment_code_start);\n")
	fd.write("\t};\n\n")

	fd.write("};\n\n");
	fd.write("#endif\n\n");
	fd.close();


def build_hlsl_dx9_headers( target, source, env ):

	for x in source:

		build_hlsl_dx9_header(str(x));


	return 0


def build_legacygl_header( filename, include, class_suffix, output_attribs ):

	fs = open(filename,"r")
	line=fs.readline()

	vertex_lines=[]
	fragment_lines=[]
	uniforms=[]
	attributes=[]
	fbos=[]
	conditionals=[]
	enums={}
	enum_constants=[]
	texunits=[]
	texunit_names=[]
	ubos=[]
	ubo_names=[]

	reading=""
	line_offset=0
	vertex_offset=0
	fragment_offset=0

	while(line):

		if (line.find("[vertex]")!=-1):
			reading="vertex"
			line=fs.readline()
			line_offset+=1
			vertex_offset=line_offset
			continue

		if (line.find("[fragment]")!=-1):
			reading="fragment"
			line=fs.readline()
			line_offset+=1
			fragment_offset=line_offset
			continue

		if (line.find("#ifdef ")!=-1 or line.find("#elif defined(")!=-1):
			if (line.find("#ifdef ")!=-1):
				ifdefline = line.replace("#ifdef ","").strip()
			else:
				ifdefline = line.replace("#elif defined(","").strip()
				ifdefline = ifdefline.replace(")","").strip()

			if (line.find("_EN_")!=-1):
				enumbase = ifdefline[:ifdefline.find("_EN_")];
				ifdefline = ifdefline.replace("_EN_","_")
				line = line.replace("_EN_","_")
#				print(enumbase+":"+ifdefline);
				if (enumbase not in enums):
					enums[enumbase]=[]
				if (ifdefline not in enums[enumbase]):
					enums[enumbase].append(ifdefline);

			elif (not ifdefline in conditionals):
				conditionals+=[ifdefline]

		if (line.find("uniform")!=-1 and line.lower().find("texunit:")!=-1):
			#texture unit
			texunitstr = line[line.find(":")+1:].strip()
			if (texunitstr=="auto"):
				texunit="-1"
			else:
				texunit = str(int(texunitstr ))
			uline=line[:line.lower().find("//")]
			uline = uline.replace("uniform","");
			uline = uline.replace("highp","");
			uline = uline.replace(";","");
			lines = uline.split(",")
			for x in lines:

				x = x.strip()
				x = x[ x.rfind(" ")+1: ]
				if (x.find("[")!=-1):
					#unfiorm array
					x = x[ :x.find("[") ]

				if (not x in texunit_names):
					texunits+=[(x,texunit)]
					texunit_names+=[x]



		elif (line.find("uniform")!=-1):
			uline = line.replace("uniform","");
			uline = uline.replace(";","");
			lines = uline.split(",")
			for x in lines:

				x = x.strip()
				x = x[ x.rfind(" ")+1: ]
				if (x.find("[")!=-1):
					#unfiorm array
					x = x[ :x.find("[") ]

				if (not x in uniforms):
					uniforms+=[x]


		if ((line.strip().find("in ")==0 or line.strip().find("attribute ")==0) and line.find("attrib:")!=-1):
			uline = line.replace("in ","");
			uline = uline.replace("attribute ","");
			uline = uline.replace("highp ","");
			uline = uline.replace(";","");
			uline = uline[ uline.find(" "): ].strip()


			if (uline.find("//")!=-1):
				name,bind = uline.split("//")
				if (bind.find("attrib:")!=-1):
					name=name.strip()
					bind=bind.replace("attrib:","").strip()
					attributes+=[(name,bind)]


		line=line.replace("\r","")
		line=line.replace("\n","")
		#line=line.replace("\\","\\\\")
		#line=line.replace("\"","\\\"")
		#line=line+"\\n\\"

		if (reading=="vertex"):
			vertex_lines+=[line]
		if (reading=="fragment"):
			fragment_lines+=[line]

		line=fs.readline()
		line_offset+=1

	fs.close();

	out_file = filename+".h"
	fd = open(out_file,"w")

	fd.write("/* WARNING, THIS FILE WAS GENERATED, DO NOT EDIT */\n");

	out_file_base = out_file
	out_file_base = out_file_base[ out_file_base.rfind("/")+1: ]
	out_file_base = out_file_base[ out_file_base.rfind("\\")+1: ]
#	print("out file "+out_file+" base " +out_file_base)
	out_file_ifdef = out_file_base.replace(".","_").upper()
	fd.write("#ifndef "+out_file_ifdef+class_suffix+"_120\n")
	fd.write("#define "+out_file_ifdef+class_suffix+"_120\n")

	out_file_class = out_file_base.replace(".glsl.h","").title().replace("_","").replace(".","")+"Shader"+class_suffix;
	fd.write("\n\n");
	fd.write("#include \"" + include + "\"\n\n\n");
	fd.write("class "+out_file_class+" : public Shader"+class_suffix+" {\n\n");
	fd.write("\t virtual String get_shader_name() const { return \""+out_file_class+"\"; }\n");


	fd.write("public:\n\n");

	if (len(conditionals)):
		fd.write("\tenum Conditionals {\n");
		for x in conditionals:
			fd.write("\t\t"+x.upper()+",\n");
		fd.write("\t};\n\n");


	if (len(uniforms)):
		fd.write("\tenum Uniforms {\n");
		for x in uniforms:
			fd.write("\t\t"+x.upper()+",\n");
		fd.write("\t};\n\n");

	fd.write("\t_FORCE_INLINE_ int get_uniform(Uniforms p_uniform) const { return _get_uniform(p_uniform); }\n\n");
	if (len(conditionals)):

		fd.write("\t_FORCE_INLINE_ void set_conditional(Conditionals p_conditional,bool p_enable)  {  _set_conditional(p_conditional,p_enable); }\n\n");
	fd.write("\t#define _FU if (get_uniform(p_uniform)<0) return; ERR_FAIL_COND( get_active()!=this );\n\n ");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_value) { _FU glUniform1f(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, double p_value) { _FU glUniform1f(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint8_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int8_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint16_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int16_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint32_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int32_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, uint64_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, int64_t p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, unsigned long p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	#fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, long p_value) { _FU glUniform1i(get_uniform(p_uniform),p_value); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Color& p_color) { _FU GLfloat col[4]={p_color.r,p_color.g,p_color.b,p_color.a}; glUniform4fv(get_uniform(p_uniform),1,col); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector2& p_vec2) { _FU GLfloat vec2[2]={p_vec2.x,p_vec2.y}; glUniform2fv(get_uniform(p_uniform),1,vec2); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Vector3& p_vec3) { _FU GLfloat vec3[3]={p_vec3.x,p_vec3.y,p_vec3.z}; glUniform3fv(get_uniform(p_uniform),1,vec3); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b) { _FU glUniform2f(get_uniform(p_uniform),p_a,p_b); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c) { _FU glUniform3f(get_uniform(p_uniform),p_a,p_b,p_c); }\n\n");
	fd.write("\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, float p_a, float p_b, float p_c, float p_d) { _FU glUniform4f(get_uniform(p_uniform),p_a,p_b,p_c,p_d); }\n\n");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Transform& p_transform) {  _FU

		const Transform &tr = p_transform;

		GLfloat matrix[16]={ /* build a 16x16 matrix */
			tr.basis.elements[0][0],
			tr.basis.elements[1][0],
			tr.basis.elements[2][0],
			0,
			tr.basis.elements[0][1],
			tr.basis.elements[1][1],
			tr.basis.elements[2][1],
			0,
			tr.basis.elements[0][2],
			tr.basis.elements[1][2],
			tr.basis.elements[2][2],
			0,
			tr.origin.x,
			tr.origin.y,
			tr.origin.z,
			1
		};


	glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);


	}

	""");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const Matrix32& p_transform) {  _FU

		const Matrix32 &tr = p_transform;

		GLfloat matrix[16]={ /* build a 16x16 matrix */
			tr.elements[0][0],
			tr.elements[0][1],
			0,
			0,
			tr.elements[1][0],
			tr.elements[1][1],
			0,
			0,
			0,
			0,
			1,
			0,
			tr.elements[2][0],
			tr.elements[2][1],
			0,
			1
		};


	glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);


	}

	""");

	fd.write("""\t_FORCE_INLINE_ void set_uniform(Uniforms p_uniform, const CameraMatrix& p_matrix) {  _FU

		GLfloat matrix[16];

		for (int i=0;i<4;i++) {
			for (int j=0;j<4;j++) {

				matrix[i*4+j]=p_matrix.matrix[i][j];
			}
		}

		glUniformMatrix4fv(get_uniform(p_uniform),1,false,matrix);
	}; """);

	fd.write("\n\n#undef _FU\n\n\n");


	fd.write("\tvirtual void init() {\n\n");


	enum_value_count=0;

	if (len(enums)):

		fd.write("\t\t//Written using math, given nonstandarity of 64 bits integer constants..\n");
		fd.write("\t\tstatic const Enum _enums[]={\n")

		bitofs=len(conditionals)
		enum_vals=[]

		for xv in enums:
			x=enums[xv]
			bits=1
			amt = len(x);
#			print(x)
			while(2**bits < amt):
				bits+=1
#			print("amount: "+str(amt)+" bits "+str(bits));
			strs="{"
			for i in range(amt):
				strs+="\"#define "+x[i]+"\\n\","

				v={}
				v["set_mask"]="uint64_t("+str(i)+")<<"+str(bitofs)
				v["clear_mask"]="((uint64_t(1)<<40)-1) ^ (((uint64_t(1)<<"+str(bits)+") - 1)<<"+str(bitofs)+")"
				enum_vals.append(v)
				enum_constants.append(x[i])

			strs+="NULL}"

			fd.write("\t\t\t{(uint64_t(1<<"+str(bits)+")-1)<<"+str(bitofs)+","+str(bitofs)+","+strs+"},\n");
			bitofs+=bits


		fd.write("\t\t};\n\n");

		fd.write("\t\tstatic const EnumValue _enum_values[]={\n")

		enum_value_count=len(enum_vals);
		for x in enum_vals:
			fd.write("\t\t\t{"+x["set_mask"]+","+x["clear_mask"]+"},\n");

		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const Enum *_enums=NULL;\n")
		fd.write("\t\tstatic const EnumValue *_enum_values=NULL;\n")

	if (len(conditionals)):

		fd.write("\t\tstatic const char* _conditional_strings[]={\n")
		if (len(conditionals)):
			for x in conditionals:
				fd.write("\t\t\t\"#define "+x+"\\n\",\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_conditional_strings=NULL;\n")

	if (len(uniforms)):

		fd.write("\t\tstatic const char* _uniform_strings[]={\n")
		if (len(uniforms)):
			for x in uniforms:
				fd.write("\t\t\t\""+x+"\",\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic const char **_uniform_strings=NULL;\n")

	if output_attribs:
		if (len(attributes)):

			fd.write("\t\tstatic AttributePair _attribute_pairs[]={\n")
			for x in attributes:
				fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
			fd.write("\t\t};\n\n");
		else:
			fd.write("\t\tstatic AttributePair *_attribute_pairs=NULL;\n")


	if (len(texunits)):
		fd.write("\t\tstatic TexUnitPair _texunit_pairs[]={\n")
		for x in texunits:
			fd.write("\t\t\t{\""+x[0]+"\","+x[1]+"},\n");
		fd.write("\t\t};\n\n");
	else:
		fd.write("\t\tstatic TexUnitPair *_texunit_pairs=NULL;\n")

	fd.write("\t\tstatic const char _vertex_code[]={\n")
	for x in vertex_lines:
		for i in range(len(x)):
			fd.write(str(ord(x[i]))+",");

		fd.write(str(ord('\n'))+",");
	fd.write("\t\t0};\n\n");

	fd.write("\t\tstatic const int _vertex_code_start="+str(vertex_offset)+";\n")


	fd.write("\t\tstatic const char _fragment_code[]={\n")
	for x in fragment_lines:
		for i in range(len(x)):
			fd.write(str(ord(x[i]))+",");

		fd.write(str(ord('\n'))+",");
	fd.write("\t\t0};\n\n");

	fd.write("\t\tstatic const int _fragment_code_start="+str(fragment_offset)+";\n")

	if output_attribs:
		fd.write("\t\tsetup(_conditional_strings,"+str(len(conditionals))+",_uniform_strings,"+str(len(uniforms))+",_attribute_pairs,"+str(len(attributes))+", _texunit_pairs,"+str(len(texunits))+",_vertex_code,_fragment_code,_vertex_code_start,_fragment_code_start);\n")
	else:
		fd.write("\t\tsetup(_conditional_strings,"+str(len(conditionals))+",_uniform_strings,"+str(len(uniforms))+",_texunit_pairs,"+str(len(texunits))+",_enums,"+str(len(enums))+",_enum_values,"+str(enum_value_count)+",_vertex_code,_fragment_code,_vertex_code_start,_fragment_code_start);\n")

	fd.write("\t};\n\n")


	if (len(enum_constants)):

		fd.write("\tenum EnumConditionals {\n")
		for x in enum_constants:
			fd.write("\t\t"+x.upper()+",\n");
		fd.write("\t};\n\n");
		fd.write("\tvoid set_enum_conditional(EnumConditionals p_cond) { _set_enum_conditional(p_cond); }\n")


	fd.write("};\n\n");
	fd.write("#endif\n\n");
	fd.close();


def build_legacygl_headers( target, source, env ):

	for x in source:

		build_legacygl_header(str(x), include = "drivers/legacygl/shader_lgl.h", class_suffix = "LGL", output_attribs = False);


	return 0

def build_gles2_headers( target, source, env ):

	for x in source:
		build_legacygl_header(str(x), include="drivers/gles2/shader_gles2.h", class_suffix = "GLES2", output_attribs = True)

def update_version():

	rev = "custom_build"
	
	if (os.getenv("BUILD_REVISION")!=None):
		rev=os.getenv("BUILD_REVISION")
		print("Using custom revision: "+rev)
	import version
	

	f=open("core/version.h","wb")
	f.write("#define VERSION_SHORT_NAME "+str(version.short_name)+"\n")
	f.write("#define VERSION_NAME "+str(version.name)+"\n")
	f.write("#define VERSION_MAJOR "+str(version.major)+"\n")
	f.write("#define VERSION_MINOR "+str(version.minor)+"\n")
	f.write("#define VERSION_REVISION "+str(rev)+"\n")
	f.write("#define VERSION_STATUS "+str(version.status)+"\n")

def parse_cg_file(fname, uniforms, sizes, conditionals):

	import re
	fs = open(fname, "r")
	line=fs.readline()

	while line:

		if re.match(r"^\s*uniform", line):

			res = re.match(r"uniform ([\d\w]*) ([\d\w]*)")
			type = res.groups(1)
			name = res.groups(2)

			uniforms.append(name);

			if (type.find("texobj") != -1):
				sizes.append(1);
			else:
				t = re.match(r"float(\d)x(\d)", type);
				if t:
					sizes.append(int(t.groups(1)) * int(t.groups(2)))
				else:
					t = re.match(r"float(\d)", type);
					sizes.append(int(t.groups(1)))

			if line.find("[branch]") != -1:
				conditionals.append(name);

		line = fs.readline();

	
def build_cg_shader(sname):

	vp_uniforms = []
	vp_uniform_sizes = []
	vp_conditionals = []

	parse_cg_file("vp_"+sname+".cg", vp_uniforms, vp_uniform_sizes, vp_conditionals);

	fp_uniforms = []
	fp_uniform_sizes = []
	fp_conditionals = []

	parse_cg_file("fp_"+sname+".cg", fp_uniforms, fp_uniform_sizes, fp_conditionals);

	fd = open("shader_"+sname+".cg.h", "w");

	fd.write('\n#include "shader_cell.h"\n');
	fd.write("\nclass Shader_" + sname + " : public ShaderCell {\n");
	fd.write("\n\tstatic struct VertexUniforms[] = {\n");

	offset = 0;
	for i in range(0, len(vp_uniforms)):

		fd.write('\t\t{ "%s", %d, %d },\n' % (vp_uniforms[i], offset, vp_uniform_sizes[i]))
		offset = offset + vp_uniform_sizes[i];
	fd.write("\t};\n\n");

	fd.write("public:\n\n");

	fd.write("\tenum {\n");

	for i in range(0, len(vp_uniforms)):

		fd.write('\t\tVP_%s,\n' % vp_uniforms[i].upper())

	fd.write("\t};\n");

		

import glob
def detect_modules():

	module_list=[]
	includes_cpp=""
	register_cpp=""
	unregister_cpp=""

	for x in glob.glob("modules/*"):
		if (not os.path.isdir(x)):
			continue
		x=x.replace("modules/","") # rest of world
		x=x.replace("modules\\","") # win32
		module_list.append(x)
		try:
			with open("modules/"+x+"/register_types.h"):
				includes_cpp+='#include "modules/'+x+'/register_types.h"\n'
				register_cpp+='#ifdef MODULE_'+x.upper()+'_ENABLED\n'
				register_cpp+='\tregister_'+x+'_types();\n'
				register_cpp+='#endif\n'
				unregister_cpp+='#ifdef MODULE_'+x.upper()+'_ENABLED\n'
				unregister_cpp+='\tunregister_'+x+'_types();\n'
				unregister_cpp+='#endif\n'
		except IOError:
			pass

	modules_cpp="""
// modules.cpp - THIS FILE IS GENERATED, DO NOT EDIT!!!!!!!
#include "register_module_types.h"


"""+includes_cpp+"""

void register_module_types() {

"""+register_cpp+"""

}

void unregister_module_types() {

"""+unregister_cpp+"""

}

"""

	f=open("modules/register_module_types.cpp","wb")
	f.write(modules_cpp)

	return module_list



def win32_spawn(sh, escape, cmd, args, env):
	import subprocess
	newargs = ' '.join(args[1:])
	cmdline = cmd + " " + newargs
	startupinfo = subprocess.STARTUPINFO()
	#startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
	for e in env:
		if type(env[e]) != type(""):
			env[e] = str(env[e])
	proc = subprocess.Popen(cmdline, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
		stderr=subprocess.PIPE, startupinfo=startupinfo, shell = False, env = env)
	data, err = proc.communicate()
	rv = proc.wait()
	if rv:
		print "====="
		print err
		print "====="
	return rv

"""
def win32_spawn(sh, escape, cmd, args, spawnenv):
	import win32file
	import win32event
	import win32process
	import win32security
	for var in spawnenv:
		spawnenv[var] = spawnenv[var].encode('ascii', 'replace')

	sAttrs = win32security.SECURITY_ATTRIBUTES()
	StartupInfo = win32process.STARTUPINFO()
	newargs = ' '.join(map(escape, args[1:]))
	cmdline = cmd + " " + newargs

	# check for any special operating system commands
	if cmd == 'del':
		for arg in args[1:]:
			win32file.DeleteFile(arg)
		exit_code = 0
	else:
		# otherwise execute the command.
		hProcess, hThread, dwPid, dwTid = win32process.CreateProcess(None, cmdline, None, None, 1, 0, spawnenv, None, StartupInfo)
		win32event.WaitForSingleObject(hProcess, win32event.INFINITE)
		exit_code = win32process.GetExitCodeProcess(hProcess)
		win32file.CloseHandle(hProcess);
		win32file.CloseHandle(hThread);
	return exit_code
"""

def android_module_source(self,subpath,manifest=""):
	base_path = "../../../modules/"+self.current_module+"/"+subpath
	self.android_source_modules.append(base_path)		

def android_module_library(self,subpath,manifest=""):
	base_path = ""
	if (os.path.isabs(subpath)):
		base_path=subpath
	else:
		base_path = self.Dir(".").abspath+"/modules/"+self.current_module+"/"+subpath
	self.android_module_libraries.append(base_path)		

def android_module_file(self,file):
	base_path = self.Dir(".").abspath+"/modules/"+self.current_module+"/"+file
	self.android_source_files.append(base_path)		
def android_module_manifest(self,file):
	base_path = self.Dir(".").abspath+"/modules/"+self.current_module+"/"+file
	f = open(base_path,"rb")
	self.android_manifest_chunk+=f.read()

def disable_module(self):
	self.disabled_modules.append(self.current_module)
	
def save_active_platforms(apnames,ap):

	for x in ap:
		pth = x+"/logo.png"
#		print("open path: "+pth)
		pngf=open(pth,"rb");
		b=pngf.read(1);
		str=" /* AUTOGENERATED FILE, DO NOT EDIT */ \n"
		str+=" static const unsigned char _"+x[9:]+"_logo[]={"
		while(len(b)==1):
			str+=hex(ord(b))
			b=pngf.read(1);
			if (len(b)==1):
				str+=","

		str+="};\n"
		
		wf = x+"/logo.h"
		logow = open(wf,"wb")
		logow.write(str)

def no_verbose(sys, env):

	colors = {}

	# Colors are disabled in non-TTY environments such as pipes. This means
	# that if output is redirected to a file, it will not contain color codes
	if sys.stdout.isatty():
		colors['cyan'] = '\033[96m'
		colors['purple'] = '\033[95m'
		colors['blue'] = '\033[94m'
		colors['green'] = '\033[92m'
		colors['yellow'] = '\033[93m'
		colors['red'] = '\033[91m'
		colors['end'] = '\033[0m'
	else:
		colors['cyan'] = ''
		colors['purple'] = ''
		colors['blue'] = ''
		colors['green'] = ''
		colors['yellow'] = ''
		colors['red'] = ''
		colors['end'] = ''

	compile_source_message = '%sCompiling %s==> %s$SOURCE%s' % (colors['blue'], colors['purple'], colors['yellow'], colors['end'])
	java_compile_source_message = '%sCompiling %s==> %s$SOURCE%s' % (colors['blue'], colors['purple'], colors['yellow'], colors['end'])
	compile_shared_source_message = '%sCompiling shared %s==> %s$SOURCE%s' % (colors['blue'], colors['purple'], colors['yellow'], colors['end'])
	link_program_message = '%sLinking Program        %s==> %s$TARGET%s' % (colors['red'], colors['purple'], colors['yellow'], colors['end'])
	link_library_message = '%sLinking Static Library %s==> %s$TARGET%s' % (colors['red'], colors['purple'], colors['yellow'], colors['end'])
	ranlib_library_message = '%sRanlib Library         %s==> %s$TARGET%s' % (colors['red'], colors['purple'], colors['yellow'], colors['end'])
	link_shared_library_message = '%sLinking Shared Library %s==> %s$TARGET%s' % (colors['red'], colors['purple'], colors['yellow'], colors['end'])
	java_library_message = '%sCreating Java Archive  %s==> %s$TARGET%s' % (colors['red'], colors['purple'], colors['yellow'], colors['end'])

	env.Append(CXXCOMSTR=[compile_source_message])
	env.Append(CCCOMSTR=[compile_source_message])
	env.Append(SHCCCOMSTR=[compile_shared_source_message])
	env.Append(SHCXXCOMSTR=[compile_shared_source_message])
	env.Append(ARCOMSTR=[link_library_message])
	env.Append(RANLIBCOMSTR=[ranlib_library_message])
	env.Append(SHLINKCOMSTR=[link_shared_library_message])
	env.Append(LINKCOMSTR=[link_program_message])
	env.Append(JARCOMSTR=[java_library_message])
	env.Append(JAVACCOMSTR=[java_compile_source_message])

def detect_visual_c_compiler_version(tools_env):
	# tools_env is the variable scons uses to call tools that execute tasks, SCons's env['ENV'] that executes tasks...
	# (see the SCons documentation for more information on what it does)...
	# in order for this function to be well encapsulated i choose to force it to receive SCons's TOOLS env (env['ENV']
	# and not scons setup environment (env)... so make sure you call the right environment on it or it will fail to detect
	# the proper vc version that will be called

	# These is no flag to give to visual c compilers to set the architecture, ie scons bits argument (32,64,ARM etc)
	# There are many different cl.exe files that are run, and each one compiles & links to a different architecture
	# As far as I know, the only way to figure out what compiler will be run when Scons calls cl.exe via Program()
	# is to check the PATH varaible and figure out which one will be called first. Code bellow does that and returns:
	# the following string values:

	# ""              Compiler not detected
	# "amd64"         Native 64 bit compiler
	# "amd64_x86"     64 bit Cross Compiler for 32 bit
	# "x86"           Native 32 bit compiler
	# "x86_amd64"     32 bit Cross Compiler for 64 bit

	# There are other architectures, but Godot does not support them currently, so this function does not detect arm/amd64_arm
	# and similar architectures/compilers

	# Set chosen compiler to "not detected"
	vc_chosen_compiler_index = -1
	vc_chosen_compiler_str = ""

	# Start with Pre VS 2017 checks which uses VCINSTALLDIR:
	if 'VCINSTALLDIR' in tools_env:
		# print("Checking VCINSTALLDIR")

		# find() works with -1 so big ifs bellow are needed... the simplest solution, in fact
		# First test if amd64 and amd64_x86 compilers are present in the path
		vc_amd64_compiler_detection_index = tools_env["PATH"].find(tools_env["VCINSTALLDIR"] + "BIN\\amd64;")
		if(vc_amd64_compiler_detection_index > -1):
			vc_chosen_compiler_index = vc_amd64_compiler_detection_index
			vc_chosen_compiler_str = "amd64"

		vc_amd64_x86_compiler_detection_index = tools_env["PATH"].find(tools_env["VCINSTALLDIR"] + "BIN\\amd64_x86;")
		if(vc_amd64_x86_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_amd64_x86_compiler_detection_index)):
			vc_chosen_compiler_index = vc_amd64_x86_compiler_detection_index
			vc_chosen_compiler_str = "amd64_x86"

		# Now check the 32 bit compilers
		vc_x86_compiler_detection_index = tools_env["PATH"].find(tools_env["VCINSTALLDIR"] + "BIN;")
		if(vc_x86_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_x86_compiler_detection_index)):
			vc_chosen_compiler_index = vc_x86_compiler_detection_index
			vc_chosen_compiler_str = "x86"

		vc_x86_amd64_compiler_detection_index = tools_env["PATH"].find(tools_env['VCINSTALLDIR'] + "BIN\\x86_amd64;")
		if(vc_x86_amd64_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_x86_amd64_compiler_detection_index)):
			vc_chosen_compiler_index = vc_x86_amd64_compiler_detection_index
			vc_chosen_compiler_str = "x86_amd64"

	# and for VS 2017 and newer we check VCTOOLSINSTALLDIR:
	if 'VCTOOLSINSTALLDIR' in tools_env:
		# print("Checking VCTOOLSINSTALLDIR")

		# Newer versions have a different path available
		vc_amd64_compiler_detection_index = tools_env["PATH"].upper().find(tools_env['VCTOOLSINSTALLDIR'].upper() + "BIN\\HOSTX64\\X64;")
		if(vc_amd64_compiler_detection_index > -1):
			vc_chosen_compiler_index = vc_amd64_compiler_detection_index
			vc_chosen_compiler_str = "amd64"

		vc_amd64_x86_compiler_detection_index = tools_env["PATH"].upper().find(tools_env['VCTOOLSINSTALLDIR'].upper() + "BIN\\HOSTX64\\X86;")
		if(vc_amd64_x86_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_amd64_x86_compiler_detection_index)):
			vc_chosen_compiler_index = vc_amd64_x86_compiler_detection_index
			vc_chosen_compiler_str = "amd64_x86"

		vc_x86_compiler_detection_index = tools_env["PATH"].upper().find(tools_env['VCTOOLSINSTALLDIR'].upper() + "BIN\\HOSTX86\\X86;")
		if(vc_x86_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_x86_compiler_detection_index)):
			vc_chosen_compiler_index = vc_x86_compiler_detection_index
			vc_chosen_compiler_str = "x86"

		vc_x86_amd64_compiler_detection_index = tools_env["PATH"].upper().find(tools_env['VCTOOLSINSTALLDIR'].upper() + "BIN\\HOSTX86\\X64;")
		if(vc_x86_amd64_compiler_detection_index > -1
		   and (vc_chosen_compiler_index == -1
				or vc_chosen_compiler_index > vc_x86_amd64_compiler_detection_index)):
			vc_chosen_compiler_index = vc_x86_amd64_compiler_detection_index
			vc_chosen_compiler_str = "x86_amd64"

	# debug help
	# print(vc_amd64_compiler_detection_index)
	# print(vc_amd64_x86_compiler_detection_index)
	# print(vc_x86_compiler_detection_index)
	# print(vc_x86_amd64_compiler_detection_index)
	# print("chosen "+str(vc_chosen_compiler_index)+ " | "+str(vc_chosen_compiler_str))

	return vc_chosen_compiler_str

def find_visual_c_batch_file(env):
	from  SCons.Tool.MSCommon.vc import get_default_version, get_host_target, find_batch_file

	version = get_default_version(env)
	(host_platform, target_platform,req_target_platform) = get_host_target(env)
	return find_batch_file(env, version, host_platform, target_platform)[0]

def generate_vs_project(env, num_jobs):
	batch_file = find_visual_c_batch_file(env)
	if batch_file:
		def build_commandline(commands):
			common_build_prefix = ['cmd /V /C set "plat=$(PlatformTarget)"',
									'(if "$(PlatformTarget)"=="x64" (set "plat=x86_amd64"))',
									'set "tools=yes"',
									'(if "$(Configuration)"=="release" (set "tools=no"))',
									'call "' + batch_file + '" !plat!']

			result = " ^& ".join(common_build_prefix + [commands])
			# print("Building commandline: ", result)
			return result

		env.AddToVSProject(env.core_sources)
		env.AddToVSProject(env.main_sources)
		env.AddToVSProject(env.modules_sources)
		env.AddToVSProject(env.scene_sources)
		env.AddToVSProject(env.servers_sources)
		env.AddToVSProject(env.drivers_sources)
		#env.AddToVSProject(env.editor_sources)

		env['MSVSBUILDCOM'] = build_commandline('scons --directory=$(ProjectDir) platform=windows target=$(Configuration) tools=!tools! -j' + str(num_jobs))
		env['MSVSREBUILDCOM'] = build_commandline('scons --directory=$(ProjectDir) platform=windows target=$(Configuration) tools=!tools! vsproj=yes -j' + str(num_jobs))
		env['MSVSCLEANCOM'] = build_commandline('scons --directory=$(ProjectDir) --clean platform=windows target=$(Configuration) tools=!tools! -j' + str(num_jobs))

		# This version information (Win32, x64, Debug, Release, Release_Debug seems to be
		# required for Visual Studio to understand that it needs to generate an NMAKE
		# project. Do not modify without knowing what you are doing.
		debug_variants = ['debug|Win32'] + ['debug|x64']
		release_variants = ['release|Win32'] + ['release|x64']
		release_debug_variants = ['release_debug|Win32'] + ['release_debug|x64']
		variants = debug_variants + release_variants + release_debug_variants
		debug_targets = ['bin\\godot.windows.tools.32.exe'] + ['bin\\godot.windows.tools.64.exe']
		release_targets = ['bin\\godot.windows.opt.32.exe'] + ['bin\\godot.windows.opt.64.exe']
		release_debug_targets = ['bin\\godot.windows.opt.tools.32.exe'] + ['bin\\godot.windows.opt.tools.64.exe']
		targets = debug_targets + release_targets + release_debug_targets
		msvproj = env.MSVSProject(target=['#godot' + env['MSVSPROJECTSUFFIX']],
									incs=env.vs_incs,
									srcs=env.vs_srcs,
									runfile=targets,
									buildtarget=targets,
									auto_build_solution=1,
									variant=variants)
	else:
		print("Could not locate Visual Studio batch file for setting up the build environment. Not generating VS project.")

def precious_program(env, program, sources, **args):
	program = env.ProgramOriginal(program, sources, **args)
	env.Precious(program)
	return program

def add_shared_library(env, name, sources, **args):
	library = env.SharedLibrary(name, sources, **args)
	env.NoCache(library)
	return library

def add_library(env, name, sources, **args):
	library = env.Library(name, sources, **args)
	env.NoCache(library)
	return library

def add_program(env, name, sources, **args):
	program = env.Program(name, sources, **args)
	env.NoCache(program)
	return program

def CommandNoCache(env, target, sources, command, **args):
	result = env.Command(target, sources, command, **args)
	env.NoCache(result)
	return result
